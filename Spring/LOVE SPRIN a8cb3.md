# LOVE SPRING

spring을 사용하지 않은 (java)코드로 작성 후, spring과 비교하며 spring의 필요성에 이해해본다.

2000년대 초반엔, 자바 진영의 표준기술로 EJB가 있었다.

(어렵고, 복잡하고, 느림)

스프링, 하이버네이트라는 대체 오픈소스가 만들어짐

로드존슨이 EJB를 비판하며 스프링을 만들었다. (단순함의 승리, 사실상 표준)

하이버네이트 만든 사람을 데려와서 JPA(표준 인터페이스)를 만듦

자바 시장의 ORM 시장은 거의 JPA, 구현체로는 80퍼센트 이상 하이버네이트가 쓰임

지금 java 시장에서 중요한 것은 spring과 jpa.

스프링 부트 - 설정 편리, 서버 내장

- 스프링 프레임워크

핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타

웹 기술 : 스프링 MVC, 스프링 WebFlux

데이터 접근 기술 : 트랜잭션, JDBC, ORM, XML

기술 통합:캐시, 이메일, 원격접근, 스케줄링

테스트:스프링 기반 테스트 지원

언어:코틀린, 그루비

- 스프링 부트

스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본을 사용

단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성

Tomcat같은 웹 서버 내장해서 별도의 웹 서버 설치하지 않아도 됨

손쉬운 빌드 귀성을 위한 starter 종속성 제공

스프링과 3rd path(외부) 라이브러리 자동 구성

메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공

관례에 의한 간결한 설정

‘스프링’이라는 단어는 문맥에 따라 다르다

1. 스프링 DI 컨테이터 기술
2. 스프링 프레임워크
3. 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계

스프링은 왜 만들었을까?

‘핵심 개념’ 은 항상 단순하게 시작.

스프링의 핵심 : 자바 언어(객체 지향 언어)의 프레임워크

좋은 객체 지향 애플리케이션을 개발할 수 있도록 도와주는 프레임워크 !

예전의 EJB는 프레임워크에 종속되고 복잡했기 때문에 자바 순수의 객체 지향 프로그래밍 하기 어려웠음.

좋은 객체 지향 프로그램이란?

명령어의 목록이 아닌 “객체”들의 모임

객체는 메시지를 주고 받고, 데이터를 처리.

프로그램을 유연하고 변경하기 용이하기 만들기에 대규모 소프트웨어 개발에 많이 사용 → 다형성 !

세상이 역할과 구현으로 분리된다면

자동차의 구현이 달라져도 (모델이 달라져도) 운전자는 자동차를 운전 가능. 운전자의 역할과 자동차의 역할은 동일함

이렇게 다른 모양으로 바꾸더라도 기존의 역할을 할 수 있는 것.. 클라이언트에 영향을 주지 않고(운전자의 역할), 새로운 구현(새로운 모델)이 가능해지는 것.

클라이 언트는 대상의 역할(인터페이스)만 알면 된다. 

구현 대상의 내부 구조를 몰라도 된다.

구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.

구현 대상 자체를 변경해도 영향을 받지 않는다.

자바 언어의 다형성을 활용

역할 = 인터페이스

구현 = 인터페이스를 구현한 클래스, 구현 객체

객체를 설계할 때 역할과 구현을 명확히 분리

객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기

자바 언어의 다형성 : 오버라이딩

다형성의 본질 : 

1. 인터페이스를 구현한 객체 인스턴스를 실행 시점에 변경 가능함
2. 협력 이라는 객체사이의 관계에서 시작
3. 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경

한계 : 인터페이스 자체가 변하면, 클라이언트와 서버 모두 큰 변경 발생 ..

인터페이스를 안정적으로 잘 설계하는 것이 중요하다.

스프링과 객체 지향

다형성이 가장 중요하다.

스프링은 다형성을 극대화해서 이용할 수 있게 해준다.

제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.

스프링을 사용하면 구현을 편리하게 변경할 수 있다.

좋은 객체 지향 설계의 5가지 원칙(SOLID)

SRP : 단일 책임 원칙

Single Responsibility Principle

- 한 클래스는 하나의 책임만 가져야 한다.
- 그러나 하나의 책임은 모호
- so, 변경을 기준. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것

OCP: 개방-폐쇄 원칙

Open/Closed Principle

소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.

(여러가지 구현을 더 만들수는 있으나, 코드를 변경하지는 않게)

(문제점)

구현 객체를 변경하려면 클라이언트 코드를 변경해야한다.

분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다.

어떻게 해결? → 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.

LSP: 리스코프 치환 원칙

Liskov Substitution Principle

프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야한다. (자동차 속력을 바꾼다 한들 정확성을 깨뜨리지 않음)

하위 클래스는 인터페이스 규약을 다 지켜야한다는 것. 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면 이 원칙 필요

ISP: 인터페이스 분리 원칙

Interface Segregation Principle

특정 인터페이스를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.

운전 / 정비를 함께 두는 것보다 따로. 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음. 인터페이스가 명확해지고, 대체 가능성이 높아짐

DIP: 의존관계 역전 원칙

Dependency inversion principle

“추상화에 의존해야지, 구체화에 의존하면 안된다.”. 구현할 때 인터페이스를 바라보고 해야지 구현클래스에 의존하지 말것. 역할에 의존해야 한다. 인터페이스에 의존해야 구현체를 변경할 수 있다. 구현체에 의존하면 변경이 어렵다.

하지만 앞서 예제에서는 인터페이스에도 의존하지만 구현 클래스에도 의존. DIP 위반한 것. 

정리

객체 지향의 핵심은 다형성.

다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.

다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다. 

OCP, DIP를 지킬 수 없다.

뭔가 더 필요하다.

IoC, DI, 그리고 컨테이너

제어의 역전 (IoC) (Inversion of Control) :

개발자가 직접 컨트롤하고 제어하는 것이 아닌, 프레임워크와 같은 것들이 내 코드를 대신 호출해주는 것.

프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리한느 것을 제어의 역전(IoC)라고 한다.

프레임워크 vs 라이브러리 :

프레임워크가 내가 작성한 코드를 제어하고, 대신 실행한다 (JUnit)

라이브러리 : 내가 작성한 코드가 직접 제어의 흐름을 담당한다면, 라이브러리다.

의존관계 주입 (DI)

정적인 클래스 의존관계 :

클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다.

(App을 실행하지 않고도 알 수 있음)

동적인 객체 의존 관계 : 코드만 보고 의존관계를 쉽게 판단할 수 없는 것. 실행시켜봐야 알 수 있는 것.

App 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 ‘**의존관계 주입**’이라고 한다.

DI를 활용하면 클라이언트의 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.

DI를 활용하면, 정적인 클래스 의존관계를 변경하지 않고 동적인 의존관계를 변경할 수 있다.

IoC 컨테이너, DI 컨테이너 :

AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 IoC 컨테이너, 또는 DI 컨테이너라고 한다.

의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라고 한다. 또한 어셈블러, 오브젝트 팩토리 등으로 불리기도 한다.

스프링 컨테이너

ApplicationContext를 스프링 컨테이너라고 한다.

기존에는 AppConfig를 사용해서 객체를 생성하고 DI 했다면, 이제부터 스프링 컨테이너를 사용

스프링 컨테이너는 @Configuration 이 붙은 AppConfig를 설정 정보로 사용하여, @Bean을 모두 호출하여 스프링 컨테이너에 객체를 등록함

스프링 빈은 메서드 명을 스프링빈 이름으로 사용한다.

스프링 빈은 applicationContext.getBean() 메서드를 사용해서 찾는다.

→ 스프링 컨테이너를 사용하면 어떤 장점이 있을까?

BeanFactory : 스트링빈의 최상위 인터페이스

ApplicationContext : BeanFactory의 기능을 모두 상속받아 제공

App을 개발할 때는 빈을 관리하고 조회하는 기능은 물론이고, 수 많은 부가 기능이 필요하다 (ApplicationContext에서 제공!)

- 메시지소스를 활용한 국제화 기능 : 한국에서 들어오면 한국어로, 영미권에서 들어오면 영어로 출력
- 환경변수 : 로컬, 개발, 운영들을 구분해서 처리
- 애플리케이션 이벤트 : 이벤트를 발행하고 구독하는 모델을 편리하게 지원
- 편리한 리소스 조회 : 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회

BeanFactory나 ApplicationContext를 스프링 컨테이너라고 한다.

[AppConfig.class (자바 코드)가 아닌, XML을 사용하는 방법]

보통 자바 코드가 쓰이긴 한다.

지금까지는 new AnnotationConfigApplicationContext(AppConfig.class)

많은 러거시 파일들은 XML을 사용하기에...

스트링 빈 설정 메타 정보 - BeanDefinition

어떻게 다양할 설정 형식을 지원할까? (java, xml ...) →Bean definition 이라는 추상화가 있기 때문에...

- 빈 설정 메타정보다.
- @Bean, <bean> 당 각각 하나씩 메타 정보가 생성된다.

스프링이 다양한 설정 정보를 BeanDefinition으로 추상화해서 사용한다 !

BeanDefinition 을 등록하는 방법은 1.직접 스트링빈 등록, 2.Factory빈을 이용하는 방법이 있는데

기존의 자바 Config 방법은 2번 방법에 해당

싱글톤 ?

웹 App과 싱글톤

스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생했다.

대부분의 스프링 애플리케이션은 웹 애플리케이션이다. 물론 웹이 아닌 app 개발도 얼마든지 개발할 수 있다.

웹 어플리케이션은 보통 여러 고객이 동시에 요청을 한다.

고객이 3번 요청하면 객체를 3개씩 만들고... 그럼 고객이 많아지면?

—> 스프링 없는 순수한 DI 컨테이너인 AppConfig는 요청할 때마다 객체를 새로 생성한다...

이렇게 낭비하기 보다는 해당 객체를 딱 1개 생성하고, 공유하도록 설계하는 것이 좋다.

싱글톤 패턴

- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 함
- private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막는다

스프링 컨테이너는 객체를 기본적으로 싱글톤으로 만든다. (성능이 좋음)

싱글톤 패턴을 사용하면, 객체를 생성하는 것이 아니라 한가지를 만들어줌.

[싱글톤의 단점]

구현하는 코드 자체가 많이 들어간다.

의존관계상 클라이언트가 구체 클래스에 의존한다. (DIP 위반) - .getInstance를 해야하기 때문에 ..

클라이언트가 구체 클래스에 의존하므로 OCP 원칙을 위반할 가능성이 있다.

테스트 하기 어렵다. (인스턴스를 미리 받아 설정이 끝났기에.. 유연하게 사용하기 어려움)

자식 클래스를 만들기 어렵고 유연성이 떨어진다.

스프링 프레임워크는 싱글톤의 단점을 다 제거함 !

- 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 됨
- DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤을 사용할 수 있다.

[싱글톤 방식의 주의점 !]

- 상태를 유지하게 설계하면 안된다. (무상태여야 한다.)
- 특정 클라이언트에 의존적인 필드가 있으면 안된다
- 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
- 가급적이면 읽기만 가능해야 한다.
- 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
- (쓰레드 로컬 알아보기 !!!)

Configuration 과 싱글톤 (바이트코드 조작의 마법)

스프링이 CGLIB이라는 바이트코드 조작 라이브러리를 사용해서 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고, 그 다른 클래스를 스프링 빈으로 등록한다.

AppConfig → AppConfig@CGLIB

@Configuration 을 적용한다면, 바이트코드를 조작하고 싱글톤 보장.

붙이지 않는다면 ? 바이트를 조작하지 않음. 싱글톤을 보장하지 않음.

**컴포넌트 스캔**

컴포넌트 스캔과 의존관계 자동 주입 시작하기.

스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다.

또, 의존관계도 자동으로 주입하는 @Autowired를 지원한다.

cf. `AnnotationConfigApplicationContext`

![스크린샷 2022-02-24 오후 7.59.34.png](LOVE%20SPRIN%20a8cb3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-02-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.59.34.png)

![스크린샷 2022-02-24 오후 7.59.43.png](LOVE%20SPRIN%20a8cb3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-02-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.59.43.png)

Spring에서 Bean의 생성과 Bean들의 관계설정 같은 제어를 담당하는 IoC 오브젝트를 BeanFactory라고 한다.

보통 BeanFactory를 확장한 ApplicationContext를 사용하는데 ApplicationContext는 IoC방식을 따라 만들어진 일종의 BeanFactory라고 생각하면 된다.

BeanFactory의 종류 중 하나가 AnnotationConfigApplicationContext.

@Configure Annotation을 이용한 Java Code를 설정정보로 사용하려면 AnnotationConfigApplicationContext 를 이용한다.

1. @ComponentScan은 @Component가 붙은 모든 클래스를 스프링 빈으로 등록함

이때 스프링 빈의 기본 이름은 클래스 명을 사용하되, 맨 앞글자만 소문자를 사용한다. (임의로 지정할 수도 있다. @Component(”이름"))

1. @Autowired 의존관계 자동 주입

스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.

같은 타입을 찾아서 주입한다. (우선적으로)

컴포넌스 스캔의 탐색 위치와 기본 스캔 대상

basePackages = “hello.core.member“ : 범위를 설정해줄 수 있음. 이 패키지의 하위 패키지를 모두 탐색

basePakageClasses : 해당 클래스의 ‘패키지’부터 찾음.

지정하지 않는다면 ? Default는 ?? → 지정하지 않으면 @ComponentScan이 붙은 설정 정보 클래스의 ‘패키지’부터 하위 디렉토리를 모두 뒤져서 스프링빈을 등록한다.

“권장하는 방법”

패키지 위치를 지정하지 않고, 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것

스프링부트에는 @SpringBootApplication에 컴포넌트 스캔이 있어서 다 알아서 스프링빈 등록을 한다.

@Component 뿐만 아니라 @Controller, @Service, @Repository, @Configuration .. 도 추가됨!

그러나 사실 애노테이션(@)은 상속관계라는 것이 없다. 애노테이션이 특정 애노테이션을 들고 있는 것을 인식할 수 있는 것은 자바 언어가 지원하는 기능이 아니고, 스프링이 지원하는 기능.

필터:

includeFilter : 스캔 대상 추가

excludeFilter : 스캔 대상 제외

![스크린샷 2022-02-24 오후 8.55.52.png](LOVE%20SPRIN%20a8cb3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-02-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.55.52.png)

중복 등록과  충돌

1. 자동 빈 등록 vs 자동 빈 등록
2. 수동 빈 등록 vs 자동 빈 등록

1번은 오류를 발생시킴.

2번은 수동 빈이 우선권을 가진다. 자동 빈을 오버라이딩 한다.

그러나 스프링 부트에서는 2번 경우에서, 충돌이 나며 오류가 나도록 한다.

//개발할 때, 코드가 줄어들더라도 덜 명확해진다면 ? 코드를 동일한 걸 쓰더라도 명확해진다면? 후자가 좋다. 누가 봐도 명확하게.. 혼자만 쓰는 것이 아니므로.

**의존관계 자동 주입**

1. 생성자 주입 : 이름 그대로 생성자에서 한 번 주입받는 것. (불변, 필수(값이 무조건 있어야 한다.))
- 생성자가 1개만 있으면 Autowired를 생략할 수 있다.
1. 수정자 주입 : (setter 주입) : 선택, 변경 가능성이 있는 의존관계에 사용. 생성자보다 늦게 의존관계가 등록된다.
2. 필드 주입 : 필드에 (변수에) 바로 주입하는 방법
- 코드가 간결해서 많은 개발자들을 유혹하지만 외부에서 변경이 불가능해서 테스트하기 힘들다는 단점이 있다. DI 프레임워크가 없으면 아무것도 할 수 없다. (테스트코드(SpringBootTest)나 스프링 설정 목적의 @Configuration에서만 사용)
1. 일반 메서드 주입
- (일반적으로 생성자, 수정자로 해결)

JPA 템플릿

여태까지 한 것들 정리